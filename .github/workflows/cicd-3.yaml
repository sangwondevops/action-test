name: cicd-3 # Deploy develop, QA, production test 1 rc3
permissions:
  id-token: write
  contents: write
  pull-requests: write
on:
  push:
    paths:
      - 'my-app/**'
      - 'kubernetes/example-a/**'
      - '*.txt'
      - '.github/workflows/*'
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+-rc.[0-9]+'
  pull_request:
    types: [opened, reopened, synchronize, closed]
    branches: [develop, production]
    paths:
      - 'my-app/**'
      - 'kubernetes/example-a/**'
      - '*.txt'
      - '.github/workflows/*'

jobs:
  set-environment:
    runs-on: ubuntu-latest
    outputs:
      set-env: ${{ steps.var.outputs.set-env }}
      set-tag: ${{ steps.var.outputs.set-tag }}
    steps:
      - name: set env
        id: var
        run: |
          if [[ ${{ github.ref_type }} == "tag" ]]; then
            echo "set-env=qa" >> "$GITHUB_OUTPUT"
            REF=${{ github.ref }}
            echo "REF: $REF"
            TAG_NAME=${REF#refs/tags/}
            echo "TAG_NAME: $TAG_NAME"
            echo "set-tag=$TAG_NAME" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ ${{ github.ref_type }} == "branch" ]]; then
            if [[ ${{ github.base_ref }} == "develop" ]]; then
              echo "set-env=develop" >> "$GITHUB_OUTPUT"
              exit 0
            elif [[ ${{ github.base_ref }} == "production" ]]; then
              echo "set-env=production" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi
      - name: check output
        run: |
          echo ${{ steps.var.outputs.set-env }}
          echo ${{ steps.var.outputs.set-tag }}

  test:
    runs-on: ubuntu-latest
    steps:
      - name: checkout the code
        uses: actions/checkout@v3
      # - name: setup-node
      #   uses: actions/setup-node@v3
      #   with:
      #     node-version: 18
      # - name: Cache Node.js modules
      #   uses: actions/cache@v3
      #   with:
      #     path: ~/.npm
      #     key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      #     restore-keys: |
      #       ${{ runner.os }}-node-
      # - name: Install dependencies
      #   run: |
      #     cd my-app
      #     npm ci
      # - name: npm build
      #   run: |
      #     cd my-app
      #     npm run build

  build-image:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ["${{ needs.set-environment.outputs.set-env }}"]
    environment: ${{ matrix.environment }}
    needs: [ set-environment, test ]
    if: |
      github.event.pull_request.merged == true ||
      github.ref_type == 'tag'
    steps:
      - name: checkout the code
        uses: actions/checkout@v3
      # - name: Configure AWS Credentials
      #   id: credentials
      #   uses: aws-actions/configure-aws-credentials@v2
      #   with:
      #     aws-region: ${{ vars.AWS_REGION }}
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      # - name: Login to Amazon ECR
      #   id: login-ecr
      #   uses: aws-actions/amazon-ecr-login@v1
      # - name: docker build & push
      #   run: |
      #     docker build -f Dockerfile . \
      #     --tag ${{ env.registry }}/${{ env.repository }}:latest \
      #     --tag ${{ env.registry }}/${{ env.repository }}:${{ github.sha }}
      #     docker push ${{ env.registry }}/${{ env.repository }}:latest
      #     docker push ${{ env.registry }}/${{ env.repository }}:${{ github.sha }}
      #   env:
      #     repository: ${{ secrets.ECR_REPOSITORY }}
      #     registry: ${{ secrets.ECR_REGISTRY }}

  deploy:
    runs-on: ubuntu-latest
    needs: [ set-environment, build-image ]
    strategy:
      matrix:
        environment: ["${{ needs.set-environment.outputs.set-env }}"]
    environment: ${{ matrix.environment }}
    steps:
    - name: checkout the code
      uses: actions/checkout@v3
    # - name: Configure AWS Credentials
    #   id: credentials
    #   uses: aws-actions/configure-aws-credentials@v2
    #   with:
    #     aws-region: ${{ vars.AWS_REGION }}
    #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
    # - name: setup kubectl
    #   uses: azure/setup-kubectl@v3
    #   with:
    #     version: v1.25.0
    # - name: setup helm
    #   uses: azure/setup-helm@v3
    #   with:
    #     version: v3.7.2 
    # - name: get k8s kube-config
    #   run: |
    #     aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER }}
    # - name: deploy kubernetes manifest Using helm
    #   run: |
    #     helm upgrade --install example-a kubernetes/example-a --create-namespace --namespace example-a-${{ matrix.environment }} --wait --atomic \
    #     --timeout 15m \
    #     --values kubernetes/example-a/values/${{ matrix.environment }}/values.yaml \
    #     --set image.tag=${{ github.sha }}
  
  create-pr:
    runs-on: ubuntu-latest
    needs: [ set-environment, deploy ]
    if: |
      needs.set-environment.outputs.set-env == 'qa' 
    steps:
    - name: checkout the code
      uses: actions/checkout@v3
    - name: gh auth login
      run: |
        echo ${{ secrets.PERSONAL_ACCESS_TOKEN }} | gh auth login --with-token
    - name: tag filter
      id: filter
      run: |
        tag=${{ needs.set-environment.outputs.set-tag }}
        tag=${tag%-*}
        echo $tag
        echo "filter-tag=$tag" >> $GITHUB_OUTPUT
    - name: check release branch exist
      id: var
      run: |
        branch=$(gh pr list -s open -H release/${{ steps.filter.outputs.filter-tag }} --json headRefName | jq '.[] | .headRefName')
        echo "branch: ${branch}"
        echo "is_branch=false" >> $GITHUB_OUTPUT
        if [[ ${branch} == *"release/${{ steps.filter.outputs.filter-tag }}"* ]]; then
          echo "is_branch=true" >> $GITHUB_OUTPUT
        fi
    - name: check output 1
      run: |
        echo ${{ steps.var.outputs.is_branch }}
        echo ${{ steps.filter.outputs.filter-tag }}
    - name: create branch
      if: |
        steps.var.outputs.is_branch == 'false'
      run: |
        git checkout -b release/${{ steps.filter.outputs.filter-tag }}
        git push origin release/${{ steps.filter.outputs.filter-tag }}
    - name: Create Pull Request
      if: |
        steps.var.outputs.is_branch == 'false'
      run: |
        gh pr create --base production --title "Merge PR Release branch -> Production branch  " --body "Merge PR Release -> Production" --head release/${{ steps.filter.outputs.filter-tag }}
    - name: update branch
      if: |
        steps.var.outputs.is_branch == 'true'
      run: |
        git checkout -b release/${{ steps.filter.outputs.filter-tag }}
        git push -f origin release/${{ steps.filter.outputs.filter-tag }}
        
  slack:
    runs-on: ubuntu-latest
    needs: [set-environment, deploy]
    if: |
      always() && (needs.deploy.result == 'success' || needs.deploy.result == 'failure') 
    steps:
    - name: checkout
      run: |
        echo "hello"
    # - name: notify
    #   uses: slackapi/slack-github-action@v1.24.0
    #   with:
    #     payload: |
    #       {
    #         "text": "Deploy Result: ${{ needs.deploy.result }} in environment: ${{ needs.set-environment.outputs.set-env }}, repository: ${{ github.repository }}.",
    #         "blocks": [
    #           {
    #             "type": "section",
    #             "text": {
    #               "type": "mrkdwn",
    #               "text": "Deploy Result: ${{ needs.deploy.result }} in environment: ${{ needs.set-environment.outputs.set-env }}, repository: ${{ github.repository }}."
    #             }
    #           }
    #         ]
    #       }
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    #     SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
  
  create-release:
    runs-on: ubuntu-latest
    needs: [set-environment, deploy]
    if: |
      needs.deploy.result == 'success' && needs.set-environment.outputs.set-env == 'production' &&
      contains(github.head_ref, 'release') 
    steps:
      - name: Get tag version
        id: get_tag
        run: |
          head_ref=${{ github.head_ref }}
          release_version=${head_ref#*/}
          echo "HEAD_REF: $head_ref"
          echo "RELEASE_VERSION: $release_version"
          echo "version=$release_version" >> $GITHUB_OUTPUT
      - name: Create Release
        id: create_release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const version = "${{ steps.get_tag.outputs.version }}"
            const release = await github.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: version,
              name: "Release " + version,
              body: "Release for version " + version
            })
            return release.data.id
      - name: Output Release URL
        run: |
          echo "The URL for the release is https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_tag.outputs.version }}"
